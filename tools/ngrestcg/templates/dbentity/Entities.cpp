// This file generated by ngrestcg
// For more information, please visit: https://github.com/loentar/ngrest
// DO NOT EDIT. ANY CHANGES WILL BE LOST

##var lastNs
##var lastNsEnd
\
#include <ngrest/db/Field.h>
#include <ngrest/db/Db.h>
#include <ngrest/db/Query.h>
#include <ngrest/db/QueryImpl.h>

#include "$(interface.name)Entities.h"
\
\
##foreach $(.structs)
##ifeq($(.isExtern),false)
##include <common/nsopt.cpp>

// $(.name)

$(struct.name)Entity::$(struct.name)Entity()
{
}

const std::string& $(.name)Entity::getName() const
{
    const static std::string name("$(.name)");
    return name;
}

const std::string& $(.name)Entity::getTableName() const
{
    const static std::string tableName("$(.options.*table)");
    return tableName;
}

const std::list<std::string>& $(.name)Entity::getFieldsNames() const
{
    const static std::list<std::string> fieldsNames = {
##foreach $(.fields)
        "$(.name)",
##endfor
    };
    return fieldsNames;
}

const std::string& $(.name)Entity::getFieldsNamesStr() const
{
    const static std::string fieldsNames = "\
##var first 1
##foreach $(.fields)
##ifeq($($first),1)
##var first 0
##else
,\
##endif
$(.name)\
##endfor
";
    return fieldsNames;
}

const std::string& $(.name)Entity::getFieldsArgs() const
{
    const static std::string fieldsNames = "(\
##var first 1
##foreach $(.fields)
##ifeq($($first),1)
##var first 0
##else
,\
##endif
?\
##endfor
)";
    return fieldsNames;
}

const std::list< ::ngrest::Field>& $(.name)Entity::getFields() const
{
    const static std::list< ::ngrest::Field> fields = {
##foreach $(.fields)
        ::ngrest::Field {
            ::ngrest::Field::DataType::\
##ifeq($(.dataType.type)-$(.dataType.name),template-Nullable)
##var type $(.dataType.templateParams.templateParam1.type)
##var name $(.dataType.templateParams.templateParam1.name)
##else
##var type $(.dataType.type)
##var name $(.dataType.name)
##endif
##switch $($type)
##case string
String\
##case enum
Enum\
##case generic
##ifeq($($name.!match/bool/),true)
Bool\
##else
##ifeq($($name.!match/float/),true)
Float\
##else
##ifeq($($name.!match/double/),true)
Float\
##else // defaulting to int
Int  /* defaulted to int from $(.dataType) */ \
##endif // double/int
##endif // float
##endif // bool
##default
##error Cannot serialize type #1: $(.dataType)
##endswitch
, // type
            "$(.options.*type)", // DBMS type
            "$(.name)", // name
##ifeq($(.dataType.type)-$(.dataType.name),template-Nullable)
            "$(.options.*default||"NULL")", // default value
            false, // not null
##else
            "$(.options.*default)", // default value
            true, // not null
##endif
            $(.options.*pk||"false"), // pk
            $(.options.*unique||"false"), // unique
            $(.options.*autoincrement||"false"), // autoincrement
            $(.options.*ignoreOnInsert||"false"), // ignore on insert
##ifneq($(.options.*fk),) // fk
##var fkTable $(.options.fk.!token/ /)
##var fkField $(.options.fk.!lasttoken/ /)
##var entity
##foreach $(project.interfaces)
##foreach $(interface.structs)
##ifeq($(struct.options.*table),$($fkTable))
##var entity $(struct.nsName)
##endif
##endfor
##endfor
\
##ifeq($($entity),)
##error Cannot find FK reference to table $($fkTable). Referenced from from $(.name) [$(.options.fk)]
##endif
            new ::ngrest::ForeignKey {
                "$(.options.*key||"$(struct.options.table)_fk_$($fkTable)_$($fkField)")",
                ::ngrest::getEntityByDataType< $($entity) >(),
                "$($fkField)",
                "$(.options.*onDelete)",
                "$(.options.*onUpdate)"
            }

##else
            nullptr // foreignKey
##endif // fk
        },
##endfor
    };
    return fields;
}

##endif
##endfor
$($lastNsEnd)

namespace ngrest {
##foreach $(.structs)
##ifeq($(.isExtern),false)

template <>
const Entity& getEntityByDataType< $(.nsName) >()
{
    static const $(.nsName)Entity entity;
    return entity;
}

void bindDataToQuery(Query& query, const $(struct.nsName)& data)
{
##var index 0
##foreach $(.fields)
##ifeq($(.dataType.type)-$(.dataType.name),template-Nullable)
##var type $(.dataType.templateParams.templateParam1.type)
##else
##var type $(.dataType.type)
##endif
##switch $($type)
##case enum
##ifeq($(.dataType.type)-$(.dataType.name),template-Nullable)
    if (data.$(.name).isNull()) {
        query.bindNull($($index));
    } else {
        query.bind($($index), static_cast<int>(*data.$(.name)));
    }
##else
    query.bind($($index), static_cast<int>(data.$(.name)));
##endif
##case generic||string
    query.bind($($index), data.$(.name));
##default
##error Cannot serialize type #2: $(.dataType)
##endswitch
\
##var index $($index.!inc)
\
##endfor
}

##var fieldsCount 0
##foreach $(struct.fields)
##var fieldsCount $($fieldsCount.!inc)
##endfor

void bindDataToQuery(Query& query, const $(struct.nsName)& data, const std::bitset<$($fieldsCount)>& includedFields)
{
    int index = 0;
##var index 0
##foreach $(.fields)
    if (includedFields[$($index)]) {
##ifeq($(.dataType.type)-$(.dataType.name),template-Nullable)
##var type $(.dataType.templateParams.templateParam1.type)
##else
##var type $(.dataType.type)
##endif
##switch $($type)
##case enum
##ifeq($(.dataType.type)-$(.dataType.name),template-Nullable)
        if (data.$(.name).isNull()) {
            query.bindNull(index++);
        } else {
            query.bind(index++, static_cast<int>(*data.$(.name)));
        }
##else
        query.bind(index++, static_cast<int>(data.$(.name)));
##endif
##case generic||string
        query.bind(index++, data.$(.name));
##default
##error Cannot serialize type #3: $(.dataType)
##endswitch
\
##var index $($index.!inc)
\
    }
##endfor
}

void readDataFromQuery(Query& query, $(struct.nsName)& data)
{
##var index 0
##foreach $(.fields)
##ifeq($(.dataType.type)-$(.dataType.name),template-Nullable)
##var type $(.dataType.templateParams.templateParam1.type)
##else
##var type $(.dataType.type)
##endif
##switch $($type)
##case enum
##ifeq($(.dataType.type)-$(.dataType.name),template-Nullable)
    if (query.resultIsNull($($index))) {
        data.$(.name).setNull();
    } else {
        data.$(.name).get() = static_cast< $(.dataType.templateParams.templateParam1) >(query.resultInt($($index)));
    }
##else
    data.$(.name) = static_cast< $(.dataType) >(query.resultInt($($index)));
##endif
##case generic||string
    query.result($($index), data.$(.name));
##default
##error Cannot serialize type #4: $(.dataType)
##endswitch
\
##var index $($index.!inc)
\
##endfor
}

void readDataFromQuery(Query& query, $(struct.nsName)& data, const std::bitset<$($fieldsCount)>& includedFields)
{
    int index = 0;
##var index 0
##foreach $(.fields)
    if (includedFields[$($index)]) {
##ifeq($(.dataType.type)-$(.dataType.name),template-Nullable)
##var type $(.dataType.templateParams.templateParam1.type)
##else
##var type $(.dataType.type)
##endif
##switch $($type)
##case enum
##ifeq($(.dataType.type)-$(.dataType.name),template-Nullable)
        if (data.$(.name).isNull()) {
            data.$(.name).setNull();
            ++index;
        } else {
            data.$(.name).get() = static_cast< $(.dataType.templateParams.templateParam1) >(query.resultInt(index++));
        }
##else
        data.$(.name) = static_cast< $(.dataType) >(query.resultInt(index++));
##endif
##case generic||string
        query.result(index++, data.$(.name));
##default
##error Cannot serialize type #5: $(.dataType)
##endswitch
\
##var index $($index.!inc)
\
    }
##endfor
}


##endif
##endfor

} // namespace ngrest


// debug operator helpers
##foreach $(.structs)
##ifeq($(struct.isExtern),false)
std::ostream& operator<<(std::ostream& out, const $(struct.nsName)& data)
{
##foreach $(struct.fields)
##ifeq($(.dataType.type)-$(.dataType.name),template-Nullable)
    if ((data.$(field.name).isNull())) {
        out << "\tnull";
    } else {
        out << "\t" << *data.$(field.name);
    }
##else
    out << "\t" << data.$(field.name);
##endif
##endfor
    return out;
}

##endif
##endfor
